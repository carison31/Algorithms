# Динамическое программирование
## 1. Введение
### 1.1 Предисловие
Динамическое программирование — один из наиболее мощных и изящных инструментов в арсенале программиста. Оно позволяет находить оптимальные решения для задач, которые, на первый взгляд, кажутся слишком сложными для решения стандартными методами. Ключевая сила этого подхода заключается в ***разбиении сложных проблем на более простые подзадачи***, а затем в эффективном использовании уже найденных решений для ускорения вычислений.

Этот **учебный материал** - заметки/шпаргалка для изучения динамического программирования и решения задач. Он больше подходит для тех, кто уже занимался ДП и хочет освежить знания.

## 2. Наглядное применение динамического программирования.
В этой главе поговорим о главной идее динамического программирования, а именно разделение сложной главной задачи- цели на много- много подзадач, для которых результат одной подзадачи вытекает из результата другой подзадачи. Также поговорим о мемоизации - подход, позволяющий во много раз снизить число итераций, следовательно ускорить время работы.

### 2.1 Числа Фибоначчи.
Напомню, что числа Фибоначчи это последовательность такого вида: 1, 1, 2, .., F(n) + F(n+1). Где функция F(n) - это значение n- го члена последовательности:
<img width="409" alt="image" src="https://github.com/user-attachments/assets/738f6990-5eac-4818-a5a5-0da5abdf9cb9">
Рекурсивный метод нахождения F(n):
```
def F(n):
  if n <= 1:
    return n
  else:
    return F(n-1) + F(n-2)
```
не эффективен и при n = 100, мы вовсе не дождемся ответа, так как временная сложность такого алгоритма O(2^n). То есть n-ый рекурсивный вызов функции ведет за собой 2^n рекурсивных вызовов. Заметим, что F(i) может вызываться во всем процессе несколько раз, чтобы этого избежать нам нужно запоминать вычисленные значения в массив.

Похожую идею показывает ***мемоизация***, или оно же, **динамическое программирование** сверху вниз (top-down)
Будем так же запоминать вычисления в массиве. Такой массив, нужный для сохранения уже вычисленных значений будем дальше во всех задачах называть ***dp***. dp инициализируем с длиной n + 1, так как 0-ое число - тоже член последовательности.
```
dp = [-1 for i in range(n+1)]
def F(i, dp):
    if dp[i] == -1:
        if i <= 1:
            dp[i] = i
        else:
            dp[i] = F(i - 1, dp) + F(i - 2, dp)
    return dp[i]
```
такой алгоритм уже работает за линию O(2*n) и сильно оптимизирует код. 

По сути сначала мы идем по dp сверху вниз рекурренто, пока не дойдем до базового случая. Потом, заполняя снизу вверх значенями, поднимаемся вверх "освобождая" стэк вызванных рекурсией функций.


## 3. Примеры классических задач
### 3.1 Задача о размене монеты

-Задача о размене монеты решенная методом динамического программирования (money_change.py)
-Задача о примитивном калькуляторе методом рекурсии и динамического программирования (calc.py)
