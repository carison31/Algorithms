# Динамическое программирование
## 1. Введение
### 1.1 Предисловие
Динамическое программирование — один из наиболее мощных и изящных инструментов в арсенале программиста. Оно позволяет находить оптимальные решения для задач, которые, на первый взгляд, кажутся слишком сложными для решения стандартными методами. Ключевая сила этого подхода заключается в ***разбиении сложных проблем на более простые подзадачи***, а затем в эффективном использовании уже найденных решений для ускорения вычислений.

Этот **учебный материал** - заметки/шпаргалка для изучения динамического программирования и решения задач. Он больше подходит для тех, кто уже занимался ДП и хочет освежить знания.

## 2. Наглядное применение динамического программирования.
В этой главе поговорим о главной идее динамического программирования, а именно разделение сложной главной задачи- цели на много- много подзадач, для которых результат одной подзадачи вытекает из результата другой подзадачи. Также поговорим о мемоизации - подход, позволяющий во много раз снизить число итераций, следовательно ускорить время работы.

### 2.1 Числа Фибоначчи.
Напомню, что числа Фибоначчи это последовательность такого вида: 1, 1, 2, .., F(n) + F(n+1). Где функция F(n) - это значение n- го члена последовательности:

<img width="409" alt="image" src="https://github.com/user-attachments/assets/738f6990-5eac-4818-a5a5-0da5abdf9cb9">

Рекурсивный метод нахождения F(n):
```
def F(n):
  if n <= 1:
    return n
  else:
    return F(n-1) + F(n-2)
```
не эффективен и при n = 100, мы вовсе не дождемся ответа, так как временная сложность такого алгоритма O(2^n). То есть n-ый рекурсивный вызов функции ведет за собой 2^n рекурсивных вызовов. Заметим, что F(i) может вызываться во всем процессе несколько раз, чтобы этого избежать нам нужно запоминать вычисленные значения в массив.

### 2.1.1 Top-Down
Похожую идею показывает ***мемоизация***, или оно же, **динамическое программирование** сверху вниз (top-down)
Будем так же запоминать вычисления в массиве. Такой массив, нужный для сохранения уже вычисленных значений будем дальше во всех задачах называть ***dp***. dp инициализируем с длиной n + 1, так как 0-ое число - тоже член последовательности.
```
dp = [-1 for i in range(n+1)]
def F(i, dp):
    if dp[i] == -1:
        if i <= 1:
            dp[i] = i
        else:
            dp[i] = F(i - 1, dp) + F(i - 2, dp)
    return dp[i]
```
такой алгоритм уже работает за линию O(2*n) (для сильно больших чисел O(n^2)) и сильно оптимизирует код. 

<img width="190" alt="image" src="https://github.com/user-attachments/assets/6bf9905d-e5cc-4486-ad8a-e88a94ad4ec1">

По сути сначала мы идем по dp сверху вниз рекурренто, пока не дойдем до базового случая. Потом, заполняя снизу вверх значенями, поднимаемся вверх "освобождая" стэк вызванных рекурсией функций. Общая задача: найти F(n), разибваем ее на подзадачи F(i-1).

### 2.1.2 Bottom-Up
В этом методе создаем так же dp, чем мы его заполним изначально нет разницы, пускай нулями. Введем базовые случаи, с которых начнем итерации. Будем идти итерационно по массиву вверх и сразу его заполнять. 

<img width="214" alt="image" src="https://github.com/user-attachments/assets/161a33a9-1c4f-4cbe-a47b-67f5d75341b7">

```
def F(n):
    dp = [0 for i in range(n + 1)]
    if n == 0:
        return 0
    dp[1] = 1
    for i in range (2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    return dp[n]
```
Преимущество этого метода в том, что здесь нет какого то стека функций, не тратятся ресурсы на вызов новых функций и содержания их в памяти + легче для понимания. 
Временная слодность такая же линейная O(n) (O(n^2)).

### 2.1.3 Bottom-Up Improved
Вообще говоря, необязательно знать все значения всей последовательности, чтобы вычислить следующее число Фибоначчи, достаточно знать i-1ое и i-2ое. Исправив код получим лучшую пространственную сложность в константу.
```
def F(n):
    prev = 0
    curr = 1
    if n <= 1:
        return n 
    for i in range(2, n + 1):
        ans = prev + curr
        prev = curr
        curr = ans
    return ans
```

### 2.1.4 Итоги
1. Основная идея ДП - вместо решения основной задачи, мы разбиваем ее на множество подзадач и решаем их.
2. Рекурсивный метод решения задач оптимизируется путем **мемоизации**.
3. Задачу ДП можно решить итерационно. 

## 3. Примеры классических задач
### 3.1 Задача о размене монеты

-Задача о размене монеты решенная методом динамического программирования (money_change.py)
-Задача о примитивном калькуляторе методом рекурсии и динамического программирования (calc.py)
